name: Build JAR & Deploy to EC2

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: true
        default: "main"

env:
  JAVA_VERSION: "17"
  JAVA_DIST: "temurin"
  DEPLOY_ROOT: "/home/ubuntu/cicdtest"
  REPO_NAME: "${{ github.event.repository.name }}"

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.branch || github.ref_name }}

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DIST }}

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Parse stack.yaml and detect Spring Boot project location
        id: detect_project
        run: |
          set -euo pipefail

          # Find stack.yaml file
          if [ ! -f "stack.yaml" ]; then
            echo "ERROR: stack.yaml not found in repository root"
            exit 1
          fi

          # Extract build path from stack.yaml for the spring service
          # Look for lines like "build: ./apps/spring-boot" under the spring service
          BUILD_PATH=$(grep -A 20 "spring:" stack.yaml | grep "build:" | head -n1 | sed 's/.*build: *//;s/ *$//' || echo "")

          if [ -z "$BUILD_PATH" ]; then
            echo "WARN: Could not find build path in stack.yaml, trying default locations..."
            if [ -f "./build.gradle" ] || [ -f "./settings.gradle" ]; then
              BUILD_PATH="."
            elif [ -f "./apps/spring-boot/build.gradle" ] || [ -f "./apps/spring-boot/settings.gradle" ]; then
              BUILD_PATH="./apps/spring-boot"
            else
              echo "ERROR: Could not find Spring Boot project"
              exit 1
            fi
          fi

          echo "PROJECT_DIR=${BUILD_PATH}" >> $GITHUB_OUTPUT
          echo "Found Spring Boot project at: ${BUILD_PATH}"

          # Verify the directory exists and contains gradle files
          if [ ! -d "$BUILD_PATH" ]; then
            echo "ERROR: Build path ${BUILD_PATH} does not exist"
            exit 1
          fi

          if [ ! -f "${BUILD_PATH}/build.gradle" ] && [ ! -f "${BUILD_PATH}/settings.gradle" ]; then
            echo "WARN: No Gradle files found in ${BUILD_PATH}"
          fi

      - name: Fix build.gradle for Gradle 9.x compatibility
        working-directory: ${{ steps.detect_project.outputs.PROJECT_DIR }}
        run: |
          if [ -f "build.gradle" ]; then
            echo "Checking build.gradle for compatibility issues..."

            # Fix 1: Update Spring Boot plugin version for Gradle 9.x
            if grep -q "org.springframework.boot.*version '3\.[0-3]\." build.gradle; then
              echo "Upgrading Spring Boot plugin to 3.4.0 for Gradle 9.x compatibility..."
              sed -i "s/org.springframework.boot.*version '[^']*'/org.springframework.boot' version '3.4.0'/g" build.gradle
              echo "✅ Spring Boot plugin upgraded"
            fi

            # Fix 2: Update dependency management plugin
            if grep -q "io.spring.dependency-management.*version '1\.[0-1]\." build.gradle; then
              echo "Upgrading dependency management plugin..."
              sed -i "s/io.spring.dependency-management.*version '[^']*'/io.spring.dependency-management' version '1.1.7'/g" build.gradle
              echo "✅ Dependency management plugin upgraded"
            fi

            # Fix 3: sourceCompatibility to java block
            if grep -q "^sourceCompatibility" build.gradle && ! grep -q "^java {" build.gradle; then
              echo "Converting sourceCompatibility to java block..."

              # Extract the version
              VERSION=$(grep "^sourceCompatibility" build.gradle | sed "s/sourceCompatibility[[:space:]]*=[[:space:]]*//")

              # Create new build.gradle with java block
              awk -v ver="$VERSION" '
              /^sourceCompatibility/ {
                print ""
                print "java {"
                print "    sourceCompatibility = " ver
                print "    targetCompatibility = " ver
                print "}"
                next
              }
              { print }
              ' build.gradle > build.gradle.new

              mv build.gradle.new build.gradle
              echo "✅ sourceCompatibility converted to java block"
            fi

            echo "✅ build.gradle fixed for Gradle 9.x compatibility"
            echo "--- Updated build.gradle ---"
            cat build.gradle
            echo "----------------------------"
          fi

      - name: Make gradlew executable (if exists)
        working-directory: ${{ steps.detect_project.outputs.PROJECT_DIR }}
        run: |
          if [ -f "./gradlew" ]; then
            chmod +x ./gradlew
            echo "Using Gradle Wrapper"
          else
            echo "Gradle Wrapper not found, will use gradle command"
          fi

      - name: Build Spring Boot JAR
        working-directory: ${{ steps.detect_project.outputs.PROJECT_DIR }}
        run: |
          if [ -f "./gradlew" ]; then
            ./gradlew clean bootJar --no-daemon
          else
            gradle clean bootJar --no-daemon
          fi

      - name: Prepare upload artifact
        working-directory: ${{ steps.detect_project.outputs.PROJECT_DIR }}
        run: |
          set -euo pipefail
          JAR_GLOB="build/libs/*.jar"
          UPLOAD_DIR="build/upload"
          UPLOAD_NAME="app.new.jar"
          JAR_PATH=$(ls -t ${JAR_GLOB} | head -n1)
          echo "[INFO] Picked jar: ${JAR_PATH}"
          mkdir -p "${UPLOAD_DIR}"
          cp -f "${JAR_PATH}" "${UPLOAD_DIR}/${UPLOAD_NAME}"
          ls -lh "${UPLOAD_DIR}/${UPLOAD_NAME}"

      - name: Ensure target dirs exist on EC2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            mkdir -p "${{ env.DEPLOY_ROOT }}/${{ env.REPO_NAME }}/apps/backups"

      - name: Copy Docker configuration files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "docker-compose.yml,stack.yaml,Dockerfile"
          target: ${{ env.DEPLOY_ROOT }}/${{ env.REPO_NAME }}/
          overwrite: true

      - name: Copy JAR to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: ${{ steps.detect_project.outputs.PROJECT_DIR }}/build/upload/app.new.jar
          target: ${{ env.DEPLOY_ROOT }}/${{ env.REPO_NAME }}/apps/
          overwrite: true
          strip_components: 5

      - name: Backup previous JAR, swap, and restart
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            REPO_DIR="${{ env.DEPLOY_ROOT }}/${{ env.REPO_NAME }}"
            cd "${REPO_DIR}"
            APP_DIR="${REPO_DIR}/apps"
            BACKUP_DIR="${REPO_DIR}/apps/backups"
            UPLOAD_NAME="app.new.jar"
            FINAL_NAME="app.jar"
            DOCKER_COMPOSE="sudo docker compose"

            if [ ! -s "${APP_DIR}/${UPLOAD_NAME}" ]; then
              echo "[ERROR] ${APP_DIR}/${UPLOAD_NAME} not found or empty"; exit 1
            fi

            if [ -f "${APP_DIR}/${FINAL_NAME}" ]; then
              TS=$(date +%Y%m%d-%H%M%S)
              mv -f "${APP_DIR}/${FINAL_NAME}" "${BACKUP_DIR}/app-${TS}.jar"
              echo "[INFO] Backed up to ${BACKUP_DIR}/app-${TS}.jar"
            else
              echo "[INFO] No previous ${FINAL_NAME} to backup."
            fi

            # Clean up old backups (keep only 5 most recent)
            if ls "${BACKUP_DIR}"/app-*.jar 1> /dev/null 2>&1; then
              ls -1t "${BACKUP_DIR}"/app-*.jar | tail -n +6 | xargs -r rm -f
            fi

            mv -f "${APP_DIR}/${UPLOAD_NAME}" "${APP_DIR}/${FINAL_NAME}"
            ls -lh "${APP_DIR}/${FINAL_NAME}"

            echo "[INFO] Docker compose rebuild..."
            ${DOCKER_COMPOSE} -f docker-compose.yml down
            ${DOCKER_COMPOSE} -f docker-compose.yml build spring
            echo "[INFO] Starting spring..."
            ${DOCKER_COMPOSE} -f docker-compose.yml up -d spring

            echo "[INFO] Running containers:"
            sudo docker ps --format "table {{`{{.Names}}`}}\t{{`{{.Image}}`}}\t{{`{{.Status}}`}}"

            echo "[INFO] Tail spring logs (last 80 lines):"
            CID=$(sudo docker ps -qf "name=spring" | head -n1 || true)
            if [ -n "${CID:-}" ]; then
              sudo docker logs --tail=80 "${CID}" || true
            else
              echo "[WARN] spring container not found"
            fi